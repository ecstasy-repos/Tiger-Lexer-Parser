(* The compiler from Tiger_ast to outstream  *)
structure EC =
struct

(*

The next three lines show how to interconnect the parser (generated my
ml-yacc) with the lexer (generated by ml-lex).

1. Use the `TigerLrValsFun` functor to create an `TigerLrVals`
   structure.  The `TigerLrVals` thus created has manythings required
   by the parser like the parsing table. It also has the Tokens data
   type of the language and the lexer needs to know this.

2. The substructure `TigerLrVals.Tokens` is then passed to the lexer
   generator functor `TigerLexFun` to get the lexer structure `TigerLex`

3. Finally, the lexer (available in `TigerLex`) is combined with the
   parsing data to build the parser. Note that the parser needs to
   know the lexing function as it is used by the parser to get tokens.

NOTE: The names of the structures are all controllable. For example
our functors are called TigerLrValsFun and TigerLexFun due to the line
starting with `%name` in Tiger.grm and `%header` line in the Tiger.lex
respectively.

*)

structure TigerLrVals = TigerLrValsFun(structure Token = LrParser.Token)
structure TigerLex    = TigerLexFun(structure Tokens = TigerLrVals.Tokens)
structure TigerParser = Join( structure ParserData = TigerLrVals.ParserData
			     structure Lex        = TigerLex
			     structure LrParser   = LrParser
			   )

(* 

At this point every thing regarding lexing and parsing is contained in
the TigerParser structure. Let us create a lexer using this.

*)
(* Build Lexers *)
fun makeTigerLexer strm = TigerParser.makeLexer (fn n => TextIO.inputN(strm,n))
val makeFileLexer      = makeTigerLexer o TextIO.openIn

val flag = ref ""

(* Parse command line and set a suitable lexer *)

val thisLexer = case CommandLine.arguments() of
		    []  => makeTigerLexer TextIO.stdIn
		 |  [x] => makeFileLexer x
		 |  (f1 :: f2 :: []) => (flag := f2; makeFileLexer f1)
		 |  _   => (TextIO.output(TextIO.stdErr, "usage: ec file"); OS.Process.exit OS.Process.failure)



fun print_error (s,i:int,_) = TextIO.output(TextIO.stdErr,
					    "Error, line " ^ (Int.toString i) ^ ", " ^ s ^ "\n")

val (program,_) = TigerParser.parse (0,thisLexer,print_error,()) (* parsing *)

val pp_string = PP.compile(program)
val ast_string = AST_TREE.print(program)

fun exec_helper(program,"") =  ((TextIO.output(TextIO.stdOut, ast_string)); TextIO.output(TextIO.stdOut, pp_string))
  | exec_helper(program,"--ast") = (TextIO.output(TextIO.stdOut, ast_string))
  | exec_helper(program,"--pp") = (TextIO.output(TextIO.stdOut, pp_string))
  | exec_helper(program, otherwise) = TextIO.output(TextIO.stdErr,"wrong flag")


val _ = exec_helper(program, !flag)

end